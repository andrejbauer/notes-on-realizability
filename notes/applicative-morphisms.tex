\section{Simulations}
\label{sec:simulations}%

If you open a book on computability theory, chances are that you will find a statement saying that ``models of computation are equivalent''. The claim refers to a collection of specific models of computation, such as variations of Turing machines, $\lambda$-calculi, recursive functions, and others.. The book supports the claim by describing ad hoc simulations between such models, with varying degrees of detail, after which it hurries on to core topics of computability theory. An opportunity is missed to ask about a general notion of computation, and the overall structure of models and simulations.

We seize the opportunity and do ask that such a notion be provided. An excellent one was given by John Longley~\sidecite{Longley:94}, namely \emph{applicative morphism} of PCAs. We extend his definition to account for PCAs with sub-PCAs, and dare rename it to \emph{simulation}. There are also applicative morphisms between TPCAs~\cite{longley99:_match}, but we stick to the untyped version for simplicity.

\begin{definition}
  \label{def:simulation}%
  %
  \indexsee{morphism!applicative}{applicative, morphism}%
  \indexdef{applicative!morphism}%
  \indexdef{simulation}%
  %
  A \defemph{(PCA) simulation}, originally an \defemph{applicative morphism}~\cite{Longley:94},
  $\rho: \EE \pcato \FF$ between PCAs~$\EE$ and~$\FF$ is a total relation $\rho
  \subseteq \EE \times \FF$ for which there exists a \defemph{realizer} $r \in \FF$
  %
  \indexdef{realizer!for applicative morphism}%
  \indexdef{applicative!morphism!realizer for}%
  \indexdef{realizer!for simulation}%
  \indexdef{simulation!realizer for}%
  %
  such that, for all $u, v \in \EE$ and $x, y \in \FF$,
  %
  \begin{itemize}
  \item if $\rho(u, x)$ then $\defined{r \, x}$ and
  \item if $\rho(u, x)$, $\rho(u, y)$ and $\defined{u \, v}$ then
    $\defined{r \, x \, y}$ and $\rho(u \, v, r \, x \, y)$.
  \end{itemize}
  %
  We write $\rho[u] = \set{x \in \FF \such \rho(u, x)}$.

  A \defemph{(subPCA) simulation} $\rho: (\EE, \subEE) \pcato (\FF, \subFF)$ between PCAs with subPCAs is a simulation
  $\rho : \EE \pcato \FF$ which has a realizer $r \in \subFF$, and which restricts to a simulation
  $\rho : \subEE \pcato \subFF$, with the same realizer~$r$.
\end{definition}

We defined a simulation $\rho : \EE \pcato \FF$ to be a total relation rather than a function because there might be many simulations an element of $\EE$ in $\FF$, without any one being canonical or preferred. The notation $\rho[u]$ suggests that~$\rho$ is construed as a multi-valued map rather than a mere relation.

The realizer $r \in \FF$ for a simulation~$\rho$ is an $\FF$-implementation of the application in~$\EE$.

One might expect that a simulation ought to be a map $f : \EE \to \FF$ such that $f(\combK_\EE) = \combK_\FF$, $f(\combS_\FF) = \combS_\FF$, and $f (x \cdot_\EE y) \kleq f x \cdot_\FF f y$. This is how an algebraist would define a morphism, but we are interested in the computational aspects of PCAs, not the algebraic ones.

\index{simulation!composition of}%
\index{composition!simulations}%
%
Simulations can be \defemph{composed} as relations.
If $\rho: (\EE, \subEE) \pcato (\FF, \subFF)$ and $\sigma: (\FF,
\subFF) \pcato (\GG, \subGG)$ then $\sigma \circ \rho: (\EE, \subEE)
\pcato (\GG, \subGG)$ is defined, for $x \in \EE$ and $z \in \GG$, by
%
\begin{equation*}
  z \in (\sigma \circ \rho)[x]
  \iff
  \some{y \in \FF} y \in \rho[x] \land z \in \sigma[y].
\end{equation*}

\begin{exercise}
  Show that $\sigma \circ \rho$ is realized if $\rho$ and $\sigma$ are.
\end{exercise}

The identity simulation $\id[(\EE, \subEE)]: (\EE,
\subEE) \to (\EE, \subEE)$ is the identity relation on~$\EE$. It is realized by $\pcalam{x\,y} x \, y$.

PCAs with subPCAs and simulations between them therefore form a category. We equip it with a preorder enrichment\sidenote{A category $\mathcal{C}$ is \defemph{preorder enriched} if hom-sets $\mathcal{C}(X,Y)$ are equipped with preorders (reflexive and transitive relations) under which composition is monotone.} $\preceq$ as follows.
%
\indexdef{category!of simulations}%
\index{translation, of simulations}%
\index{equivalence!of PCAs}%
%
Given $\rho, \sigma : (\EE, \subEE) \pcato (\FF, \subFF)$, define $\rho \preceq \sigma$ to hold when
there exists $t \in \subFF$ such that, for all $x \in \EE$ and $y \in \rho[x]$, $\defined{t \, x}$ and $\sigma(x, t \, y)$.
Think of~$t$ as a \defemph{translation} of $\rho$-simulations to
$\sigma$-simulations.

\begin{exercise}
  Given $\rho, \rho' : (\EE, \subEE) \pcato (\FF, \subFF)$ and $\sigma, \sigma' : (\FF, \subFF) \pcato (\GG, \subGG)$, show that if $\rho \preceq \rho'$ and $\sigma \preceq \sigma'$ then $\sigma \circ \rho \preceq \sigma' \circ \rho'$.
\end{exercise}

We write $\rho \sim \sigma$ when $\rho \preceq \sigma$ and $\sigma \preceq \rho$. An \defemph{equivalence of PCAs}
$(\EE, \subEE)$ and $(\FF, \subFF)$ is a pair of simulations
%
\begin{align*}
  \delta &: (\EE, \subEE) \pcato (\FF, \subFF),
  &
  \gamma &: (\FF, \subFF) \pcato (\EE, \subEE),
\end{align*}
%
such that $\gamma \circ \delta \sim \one_\EE$ and $\delta \circ \gamma
\sim \one_\FF$.

We identify several useful properties of simulations. These are related to the properties of functors induced by simulations, see~\cref{sec:applicative-functors}.


\begin{definition}
  A simulation $\rho: (\EE, \subEE) \to (\FF, \subFF)$ is
  %
  \indexdef{simulation!discrete}%
  \indexdef{simulation!projective}%
  \indexdef{simulation!decidable}%
  \indexdef{discrete!simulation}%
  \indexdef{projective!simulation}%
  \indexdef{decidable!simulation}%
  %
  \begin{enumerate}
  \item \defemph{discrete} when, for all $x, y \in \EE$ if $\rho[x] \cap \rho[y]$ is in inhabited then
    $x = y$.

  \item \defemph{projective} when there is a single-valued
    simulation (a function) $\rho'$ such that $\rho' \sim \rho$.

  \item \defemph{decidable} when there is $d \in \subFF$,
    called the
    %
    \indexdef{decider}%
    %
    \defemph{decider} for~$\rho$, such that, for all $x \in
    \FF$,
    %
    \begin{align*}
      x \in \rho[\combTrue_\EE] &\lthen d \, x = \combTrue_\FF,
      \\
      x \in \rho[\combFalse_\EE] &\lthen d \, x = \combFalse_\FF.
    \end{align*}
  \end{enumerate}
\end{definition}

In words, a simulation $\rho$ is discrete when distinct elements are simulated by distinct elements, projective when it is equivalent to a function, and decidable when the boolean values are simulated by values that can ne decoded as booleans in the codomain.

\begin{exercise}
  \label{exc:simulation-numerals}%
  Say that a simulation $\rho: (\EE, \subEE) \to (\FF, \subFF)$ \defemph{preserves numerals}
  when there is $c \in \subFF$ such that, for all $n \in \NN$ and $x \in \FF$,
  %
  \begin{equation*}
    x \in \rho[\overline{n}_\EE] \implies c \, x = \overline{n}_\FF.
  \end{equation*}
  %
  Prove that a simulation is decidable if, and only if, it preserves numerals.
\end{exercise}


The preorder enrichment induces a notion of adjunction.

\begin{definition}
  %
  \index{simulation!adjoint pair of}%
  \index{adjunction!simulation}%
  %
  Simulations
  %
  \begin{align*}
    \delta &: (\EE, \subEE) \pcato (\FF, \subFF),
    &
    \gamma &: (\FF, \subFF) \pcato (\EE, \subEE),
  \end{align*}
  %
  form an \defemph{adjunction}, written $\gamma \dashv \delta$, when
  %
  $\one_{\FF} \preceq \delta \circ \gamma$ and $\gamma \circ
  \delta \preceq \one_{\EE}$. We say that~$\gamma$ is \defemph{left
    adjoint} to~$\delta$, or that~$\delta$ is \defemph{right adjoint}
  to~$\gamma$.

  \indexdef{simulation!inclusion}%
  \indexdef{simulation!retraction}%
  \indexsee{inclusion!simulation}{simulation, inclusion}%
  \indexsee{retraction!simulation}{simulation, retraction}%
  %
  Such an adjoint pair is an \defemph{inclusion} when $\gamma \circ \delta \sim \id[\EE]$, and a
  \defemph{retraction} when $\delta \circ \gamma \sim \one_\FF$.
\end{definition}

To show how the above definitions can be put to work, we recall several basic results of John Longley's.

\begin{theorem}
  \label{th:simulation-properties2}%
  For $\delta: (\EE, \subEE) \pcato (\FF, \subFF)$ and
  $\gamma: (\FF, \subFF) \pcato (\EE, \subEE)$:
  %
  \begin{enumerate}
  \item
    If $\gamma \circ \delta \preceq \id[\EE]$ then $\delta$ is discrete 
    and $\gamma$ is decidable.
  \item
    If $\gamma \dashv \delta$ then $\gamma$ is projective.
  \end{enumerate}
\end{theorem}

\begin{proof}
  See \cite[Theorem 2.5.3]{Longley:94}.
\end{proof}

\begin{corollary}
  \label{th:simulation-properties}%
  If $\gamma \dashv \delta$ is a retraction then both~$\delta$
  and~$\gamma$ are discrete and decidable, and~$\gamma$ is projective.
\end{corollary}

\begin{proof}
  Immediate. This is~\cite[Corollary 2.5.4]{Longley:94}.
\end{proof}

\begin{corollary}
  \label{th:simulation-properties-more}%
  If $(\EE, \subEE)$ and $(\FF, \subFF)$ are equivalent PCAs, then the 
  there exist an equivalence
                                %
  \begin{align*}
    \delta &: (\EE, \subEE) \pcato (\FF, \subFF),
    &
    \gamma &: (\FF, \subFF) \pcato (\EE, \subEE),
  \end{align*}
                                %
  such that $\gamma$ and $\delta$ are single-valued.
\end{corollary}

\begin{proof}
  Both $\delta$ and $\gamma$ are projective by
  \cref{th:simulation-properties2}.
\end{proof}

\subsection{Examples of simulations}
\label{sec:examples-simulations}

Armed with a rigorous and general notion of simulation, we can revisit the classic examples of simulations.

\subsubsection{Initiality of $\klone$}
\label{ex:intiality-K1}%

Turing machines are distinguished by a universal property.

\begin{theorem}
  Up to equivalence, the first Kleene algebra~$\klone$ is initial in the category of PCAs and decidable simulations.
\end{theorem}

\begin{proof}
  We sketch the proof from \cite[Theorem 2.4.18]{Longley:94}. Given any PCA~$\AA$, define $\kappa : \klone \pcato \AA$ by $\kappa[n] = \set{\numeral{n}_{\AA}}$. Because every partial computable function $\NN \times \NN \parto \NN$ can be represented in~$\AA$, there is $r \in \AA$ such that, for all $k, m, n \in \NN$,
  %
  \begin{equation*}
    r \, \numeral{k} \, \numeral{m} = \numeral{n} \iff \pr{k}{m} = n.
  \end{equation*}
  %
  Such an element~$r$ realizes~$\kappa$. Furthermore, $\kappa$ is decidable because it maps numbers to numerals.

  Suppose $\mu : \klone \pcato \AA$ is another decidable simulation. Because $\mu$ preserve numerals there exists $f \in \AA$ such that if $a \in \mu[n]$ then $f \, a = \numeral{n} \in \kappa[n]$, therefore $\mu \preceq \kappa$. The relation $\kappa \preceq \mu$ holds by the exercise below, therefore $\kappa \sim \mu$.
\end{proof}

\begin{exercise}
  Verify that for any simulation $\rho : (\EE, \subEE) \pcato (\FF, \subFF)$ there is $q \in \subFF$ such that $q \, \overline{n}_{\FF} \in \rho[\overline{n}_{\EE}]$ for all $n \in \NN$.
\end{exercise}

\subsubsection{Applicative retraction between $\Lambda$ and $\klone$}
\label{ex:pcamorphism-K1-lambda}%

Recall the first Kleene algebra $\klone$ from \cref{sec:first-kleene-pca} and the untyped $\lambda$-calculus presented as a pca $\Lambda$. The elements of $\klone$ are the natural numbers encoding, and the elements of $\Lambda$ the closed terms of the untyped $\lambda$-calculus, quotiented by the $\beta$-rule.

Define $\delta : \klone \to \Lambda$ to be the map (and therefore also a total relation) which encodes numbers as Curry numerals,
%
\begin{equation*}
  \delta(n) = \numeral{n}.
\end{equation*}
%
This is a simulation because there is a closed $\lambda$-term $u$ such that $u \, \overline{m} \, \overline{n} = \overline{\pr{m}{m}}$ for all $m, n \in \NN$. The term $u$ is essentially an implementation of the universal Turing machine in the $\lambda$-calculus.

In the opposite direction, let $\gamma \subseteq \Lambda \times \NN$ be the total relation
%
\begin{equation*}
  \gamma[t] = \set{ \code{t'} \such t' \in \Lambda \land t =_\beta t' }.
\end{equation*}
%
That is, the equivalence class of a closed term $t \in \Lambda$ is the set of all codes of terms equal to~$t$.
This is a simulation because there is a partial computable map~$f : \NN \times \NN \parto \NN$ which computes the code of the application $t \, u$ from the codes of~$t$ and~$u$,
%
$f(\code{t}, \code{u}) = \code{t \, u}$.

We claim that $\gamma \circ \delta \sim \id[\klone]$.

We claim that $\delta \circ \gamma \preceq \id[\Lambda]$.

\subsubsection{Applicative adjunction between $\klone$ and $\comp{\Scott}$}
\label{ex:pcamorphism_K1_RE}%

\indexsee{applicative!adjunction}{adjunction, applicative}%
\index{adjunction!applicative!between N and P@{between~$\klone$ and~$\comp{\Scott}$}}%

There is an applicative retraction $(\delta \dashv \gamma): \comp{\Scott}
\pcato \klone$. The inclusion $\delta: \klone \to \comp{\Scott}$ is defined
by
                                %
\begin{equation*}
  \delta n = \set{n},
\end{equation*}
                                %
and the retraction $\gamma: \comp{\Scott} \pcato \klone$ is defined by
                                %
\begin{equation*}
  \gamma(U, n)
  \iff
  U = \im{\xpr{n}},
\end{equation*}
                                %
where $\xpr{\place}$ is a standard enumeration of partial
recursive functions. See~\cite[Proposition 3.3.7]{Longley:94} for
details.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Applicative retraction from $(\Scott, \comp{\Scott})$ to
  $(\Baire, \comp{\Baire})$}
\label{sec:applicative_retraction_PP_BB}%

\index{adjunction!applicative!between P and B@{between~$(\Scott, \comp{\Scott})$ and~$(\Baire, \comp{\Baire})$}}%
\index{applicative!retraction!between P and B@{between~$(\Scott, \comp{\Scott})$ and~$(\Baire, \comp{\Baire})$}}%

Lietz~\cite{Lietz:99} compared realizability models over~$\Scott$ and
over~$\Baire$ and observed that there is an applicative retraction
$(\iota \dashv \delta): PP \pcato BB$. In this subsection we
describe it explicitly and show that it is in fact a retraction from
$(\Scott, \comp{\Scott})$ to $(\Baire, \comp{\Baire})$,
                                %
\begin{equation*}
  (\iota \dashv \delta): (\Scott, \comp{\Scott}) \pcato (\Baire, \comp{\Baire}).
\end{equation*}
                                %
Given a finite sequence of natural numbers $a = \seq{a_0, \ldots,
  a_{k-1}}$, let $\code{a}$ be the encoding of~$a$ as a natural
number, as defined in Section~\ref{sec:second_kleene}. Define the
embedding $\iota: \Baire \to \Scott$ by
                                %
\begin{equation*}
  \iota \alpha =
  \set{ \code{a} \such
    a \in \NN^{*} \land a  \sqsubseteq \alpha 
    }.
\end{equation*}
                                %
Observe that if $\alpha \in \comp{\Baire}$ then $\iota \alpha \in \comp{\Scott}$.
Let $\Baire' = \im{\iota}$ and define $p: \Baire' \times \Baire' \to \Scott$
by
                                %
\begin{equation*}
  p \pair{\iota \alpha, \iota \beta} =
  \begin{cases}
    \iota (\alpha \mid \beta) 
    & \text{if $\alpha \mid \beta$ defined} \,\\
    \emptyset
    & \text{otherwise}.
  \end{cases}
\end{equation*}
                                %
The map $p$ is continuous and it can be extended to an
r.e.~enumeration operator $p: \Scott \times \Scott \to \Scott$. Thus, $p$
realizes~$\iota$, which is therefore an applicative morphism.

Let $\delta: \Scott \pcato \Baire$ be the applicative morphism defined,
for  $x \in \Scott$, $\alpha \in \Baire$, by
                                %
\begin{equation*}
  \delta(x, \alpha)
  \iff
  x = \set{n \in \NN \such \some{k \in \NN} \alpha k = n + 1}.
\end{equation*}
                                %
In words, $\alpha$ is a $\delta$-implementation of~$x$ when it
enumerates~$x$. We added~$1$ to~$n$ in the above definition so that
the empty set is enumerated as well. Clearly, if $\alpha \in \comp{\Baire}$
then~$x \in \comp{\Scott}$. In order for~$\delta$ to be an applicative
morphism, it must have a realizer~$\rho \in \comp{\Baire}$ such that
                                %
\begin{equation*}
  \delta(x, \alpha) \land
  \delta(y, \beta)
  \lthen
  \delta(x \cdot y, \rho \mid \alpha \mid \beta).
\end{equation*}
                                %
Equivalently, we may require that $\delta(x \cdot y, \rho \mid
\pair{\alpha, \beta})$. Such a~$\rho$ can be obtained as follows.
To determine the value $(\rho \mid \pair{\alpha, \beta})
(\code{(m, n)})$, let $A = \set{\alpha_0, \ldots, \alpha_{m-1}}$
and $B = \set{\beta_0, \ldots, \beta_{m-1}}$. If there exists $k
\in B$ such that $k = 1 + \code{(n, j)}$ and $\mathsf{finset}(j) \subseteq
A$ then the value is~$n+1$, otherwise it is~$0$. Clearly, this is an
effective procedure, therefore it is continuous and realized by an
element~$\rho \in \comp{\Baire}$. If we compare the definition of~$\rho$ to
the definition of application in~$\Scott$, we see that they match.

Let us show that $\iota \dashv \delta$ is an applicative retraction.
Suppose $\alpha \in \Baire$, $x = \iota(\alpha)$, and $\delta(x,
\beta)$. We can effectively reconstruct $\alpha$ from~$\beta$,
because $\beta$ enumerates the initial segments of~$\alpha$. This
shows that $\delta \circ \iota \preceq \id[\Baire]$. Also, given
$\alpha$ we can easily construct a sequence~$\beta$ which enumerates
the initial segments of~$\alpha$, therefore $\id[\Baire] \preceq
\delta \circ \iota$, and we conclude that $\delta \circ \iota \sim
\id[\Baire]$.

To see that $\iota \circ \delta \preceq \id[\Scott]$, consider $x, y \in
\Scott$ and $\alpha \in \Baire$ such that $\delta(x, \alpha)$ and $y =
\iota(\alpha)$. The sequence~$\alpha$ enumerates~$x$, and $y$
consists of the initial segments of~$\alpha$. Hence, we can
effectively reconstruct $x$ from $y$, by
                                %
\begin{equation*}
  m \in x
  \iff
  \some{n \in y} n = 1 + \code{a} \land \some{i < |a|} m = a_i.
\end{equation*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Applicative Inclusion from $(\Scott, \comp{\Scott})$ to $(\UU,
  \comp{\UU})$}
\label{sec:app_mor_PP_UU}%

\index{adjunction!applicative!between P and U@{between~$(\Scott, \comp{\Scott})$ and~$(\UU, \comp{\UU})$}}%
\index{applicative!inclusion!between P and U@{between~$(\Scott, \comp{\Scott})$ and~$(\UU, \comp{\UU})$}}%

We construct an applicative inclusion
                                %
\begin{equation*}
  (\eta \dashv \zeta): (\Scott, \comp{\Scott}) \pcato (\UU, \comp{\UU}),
\end{equation*}
                                %
with the additional property that~$\eta$ is discrete. The applicative
morphism~$\zeta$ is discrete by
Theorem~\ref{th:simulation-properties2}(1). By the Effective
Embedding Theorem~\ref{th:effective_embedding_theorem} there exists a
computable embedding $\eta: \UU \to \Scott$. Specifically,~$\eta$ is
defined by
%
\begin{equation*}
  \eta S = \set{ n \in \NN \such B_n \subseteq S },
\end{equation*}
%
where $B : \NN \to \UU$ is an effective enumeration of the compact elements. For every $n \in \NN$, let $C_n$ be the clopen set
%
\begin{equation*}
  C_n = \set{ \alpha \in \NN \such
    \alpha 0 = \cdots = \alpha n = 0 \land \alpha (n+1) = 1
    }.
\end{equation*}
%
Note that whenever $n \neq m$ then $C_n$ and $C_m$ are disjoint. The
family $\set{C_n \such n \in \NN}$ is a discrete subspace of~$\UU$.
Because~$\UU$ is an effective universal domain and $\Scott$ is an
effective domain, there exists a computable embedding-projection pair
$(\zeta, \zeta^{-}): \UU \to \Scott$. In particular, we define
$\zeta: \Scott \to \UU$ and $\zeta^{-}: \UU \to \Scott$ by
%
\begin{align*}
  \zeta x &= \bigcup_{n \in x} C_n,
  &
  \zeta^{-} S &= \set{n \in \NN \such C_n \subseteq S}.
\end{align*}
%
It is obvious that $\zeta^{-} \circ \zeta = \id[\Scott]$. Let us verify
that $\eta$ is an applicative morphism. Because it is computable, it
is the case that $\eta x \in \comp{\Scott}$ whenever $x \in \comp{\UU}$. The
application on~$\UU$ is a computable map, therefore by the Effective
Extension Theorem~\ref{th:effective_extension_theorem} there exists a
computable map $\phi: \Scott \times \Scott \to \Scott$ such that, for all $S, T
\in \UU$,
                                %
\begin{equation*}
  \eta (S \cdot T) = \phi \pair{\eta S, \eta T}.
\end{equation*}
                                %
There exists $f \in \comp{\Scott}$ such that $\phi \pair{\eta S, \eta T} = f
\cdot (\eta S) \cdot (\eta T)$ for all $S, T \in \UU$.
Therefore,~$\eta$ is an applicative morphism. We show next that
$\zeta$ is an applicative morphism. Since it is computable, $\zeta a
\in \comp{\UU}$ whenever $a \in \comp{\UU}$. Let $\gamma: \UU \times \UU \to
\UU$ be defined by
                                %
\begin{equation*}
  \gamma \pair{S, T} = \zeta ((\zeta^{-} S) \cdot (\zeta^{-} T)).
\end{equation*}
                                %
Because $\gamma$ is a composition of computable maps, it is
computable. There exists $g \in \comp{\UU}$ such that $\gamma \pair{S, T}
= g \cdot S \cdot T$ for all $S, T \in \UU$. For all $x, y \in \Scott$,
                                %
\begin{equation*}
  \zeta(x \cdot y) =
  \zeta((\zeta^{-} (\zeta x)) \cdot (\zeta^{-} (\zeta x))) =
  \gamma \pair{\zeta x, \zeta y} = g \cdot (\zeta x) \cdot (\zeta y).
\end{equation*}
                                %
Therefore, $\zeta$ is an applicative morphism.

The relations $\eta \circ \zeta \preceq \id[\Scott]$ and $\zeta \circ \eta 
\preceq \id[\UU]$ hold because $\eta \circ \zeta$ and $\zeta \circ
\eta$ are computable and realized in~$\Scott$ and~$\UU$, respectively.
Lastly, we need to verify that $\id[\Scott] \preceq \eta \circ \zeta$,
which amounts to checking that there exists a computable map $\rho:
\Scott \to \Scott$ such that $\rho \circ \eta \circ \zeta = \id[\Scott]$.
We define the graph of $\rho$ to be
%
\begin{equation*}
  m \in \rho(\set{n_1, \ldots, n_k})
  \iff
  B_{n_1} \subseteq C_m \lor \cdots \lor B_{n_k} \subseteq C_m.
\end{equation*}
%
The relation on the right-hand side is r.e.~in $m, n_1, \ldots, n_k$,
hence~$\rho$ is computable. The map~$\rho$ is the left inverse of
$\eta \circ \zeta$ because, for any $x \in \Scott$,
%
\begin{multline*}
  m \in \rho(\eta(\zeta x)) \iff
  \some{n \in \eta(\zeta x)} B_n \subseteq C_m \iff \\
  \some{k \in x} \some{n \in \NN}
      B_n \subseteq C_k \land B_n \subseteq C_m
  \iff
  m \in x.
\end{multline*}
%
Here we used the property that $\some{n \in \NN} B_n \subseteq C_k \land
  B_n \subseteq C_m$ is equivalent to $C_k \cap C_m \neq
\emptyset$, which is equivalent to $C_k = C_m$, which is equivalent to
$k = m$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Equivalence of Reflexive Continuous Lattices}
\label{sec:equivalence_reflexive_continuous_lattices}%

\index{equivalence!applicative!of reflexive continuous lattices}%
\index{continuous!lattice}%

In Subsection~\ref{sec:reflexive_cpo_model} we saw that a reflexive
CPO is a model of the untyped $\lambda$-calculus, hence a combinatory
algebra. So far we have considered two reflexive CPOs, the graph
model~$\Scott$ and the universal domain~$\UU$. In this subsection we show
that every countably based reflexive continuous lattice is equivalent
to~$\Scott$. Thus, as far as categories of modest sets on countably based
reflexive continuous lattices are concerned, we do not lose any
generality by considering only the graph model~$\Scott$.

We only consider countably based continuous lattices.
%
\index{reflexive!continuous lattice}%
\index{continuous!reflexive lattice}%
%
A continuous lattice~$L$ is \emph{reflexive} if it contains at least
two elements and its continuous function space~$L^L$ is a retract
of~$L$.

\begin{proposition}
  \label{th:PP_retract_of_reflexive_lattice}%
  The graph model is a continuous retract of every reflexive
  continuous lattice.
\end{proposition}

\begin{proof}
  \newcommand{\retr}[1]{\mathscr{R}(#1)}
  %
  Let $L$ be a reflexive continuous lattice. Then we have a
  section-retraction pair
  %
  \begin{equation*}
    \xymatrix@+1.5em{
      {L^L} \ar@<0.5ex>[r]^{\Gamma} &
      {L} \ar@<0.5ex>[l]^{\Lambda}.
      }
  \end{equation*}
  %
  The lattice~$L$ is a model of the untyped $\lambda$-calculus.
  The product $L \times L$ is a retract of~$L$. The section $p^{+}: L
  \times L \to L$ and the retraction $p^{-}: L \to L \times L$ can
  be most conveniently expressed as the untyped $\lambda$-terms as
  %
  \begin{align*}
    p^{+} \pair{x, y} &= \lam{z}{z x y},
    &
    p^{-} z &= \pair{\fst{z}, \snd{z}},
  \end{align*}
  %
  where $\fst{z} = z (\lam{x \, y} x)$ and $\snd{z} = z (\lam{x \,
    y} y)$. Let $p = p^{+} \circ p^{-}$.
  
  Let $\retr{L}$ be the continuous lattice of retractions on~$L$.
  There is a continuous pairing operation on~$\retr{L}$, defined by
  %
  \begin{equation*}
    A \times B =
    \lam{\annot{z}{L}} p^{+} \pair{
       A (\fst{(p z)}),
       B (\snd{(p z)})}.
  \end{equation*}
  %
  The Sierpinski space $\Sierpinski$ is a retract of~$L$, with the
  corresponding retraction $S: L \to L$
  %
  \begin{equation*}
    S x = 
    \begin{cases}
      \bot & \text{if $x = \bot$} \\
      \top & \text{if $x \neq \bot$}
    \end{cases}
  \end{equation*}
  %
  Let $P$ be the least retraction on $L$ satisfying the recursive
  equation
  %
  \begin{equation*}
    P = S \times P.
  \end{equation*}
  %
  The retraction $P$ is the directed supremum of the chain of
  retractions $P_0 \leq P_1 \leq \cdots$, defined by
  %
  \begin{align*}
    P_0 &= \bot,
    &
    P_{k+1} &= S \times P_k.
  \end{align*}
  %
  We abuse notation slightly and denote a retraction and its lattice
  of fixed points with the same letter. Clearly $P_k \cong
  \Sierpinski^k$ for every $k \in \NN$. Thus,~$P$ is isomorphic to the
  limit/colimit of the chain
  %
  \begin{equation*}
    \xymatrix@+1.5em{
      {\bot} \ar@<0.5ex>[r] &
      {\Sierpinski} \ar@<0.5ex>[l] \ar@<0.5ex>[r] &
      {\Sierpinski^2} \ar@<0.5ex>[l] \ar@<0.5ex>[r] &
      {\Sierpinski^3} \ar@<0.5ex>[l] \ar@<0.5ex>[r] &
      {\cdots} \ar@<0.5ex>[l],
    }
  \end{equation*}
  %
  where the pairs of arrows between the stages are the canonical
  section-retraction pairs between $\Sierpinski^k$ and
  $\Sierpinski^{k+1}$.  The limit/colimit is the
  lattice~$\Sierpinski^{\NN}$, which is isomorphic to~$\Scott$.
\end{proof}

\begin{corollary}
  \label{th:reflexive_lattices_equivalent}%
  Every two countably based reflexive continuous lattices are retracts 
  of each other, hence they are equivalent as combinatory algebras.
\end{corollary}

\begin{proof}
  If $L$ and $M$ are reflexive continuous lattices, then they are
  retracts of each other because each is a retract of~$\Scott$, and $\Scott$
  is a retract of each of them by
  Proposition~\ref{th:PP_retract_of_reflexive_lattice}.  There are
  section-retraction pairs
                                %
  \begin{align*}
    &\xymatrix@+1.5em{
      L \ar@<0.5ex>[r]^{\lambda^{+}} &
      M \ar@{->>}@<0.5ex>[l]^{\lambda^{-}}
      },
    &
    &\xymatrix@+1.5em{
      M \ar@<0.5ex>[r]^{\mu^{+}} &
      L \ar@{->>}@<0.5ex>[l]^{\mu^{-}}
      }.
  \end{align*}
                                %
  The applicative equivalence $L \sim M$ is witnessed by the sections
  $\lambda^{+}$ and $\mu^{+}$. We omit the details.
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "notes-on-realizability"
%%% End:
