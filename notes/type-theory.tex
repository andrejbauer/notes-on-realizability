\chapter{Realizability and type theory}
\label{cha:type-theory-real}

In everyday mathematics \emph{parametrized} constructions are commonplace. For
example, when a mathematical text says ``consider a continuous map $f
: [a,b] \to \RR$'', there is an
implicit use of the parametrized set $[a,b] = \set{x \in \RR \such a
  \leq x \leq b}$, where $a$ and $b$ are the parameters. 
And whenever in algebra we say ``the cyclic group $\ZZ_n$'', that is not a single group, but a \emph{family} of groups parameterized by $n \in \NN$.

The language of such parameterized constructions is \defemph{(dependent) type theory}. It is applicable in many settings, including realizability. In this chapter we shall give an interpretation of type theory in terms of families of assemblies.


\section{Families of sets}
\label{sec:families-sets}

To set the scene, let us review the set-theoretic model of type theory. A \defemph{family of sets} is a map $A : I \to \Set$ from an \defemph{index set}~$I$ to the class of all sets. We say that \emph{$A$ is indexed by~$I$} or that it is \emph{a family over base~$I$}.\sidenote{The terminology ``a family over a base'' $I$ has geometric origins, where \emph{display maps} play the role of families, and these are drawn vertically so that~$I$ is at the bottom, so a base.} Let $\Fam{I}$ be the class of all families indexed by~$I$.

Each $\Fam{I}$ is a category whose objects are the families indexed by~$I$. A morphism $f : A \to B$, where $A, B \in \Fam{I}$, is an $I$-indexed families of maps $(f_i : A_i \to B_i)_{i \in I}$. Morphisms are composed index-wise.

A map $r : J \to I$, induces \defemph{reindexing} $\invim{r} : \Fam{I} \to \Fam{J}$ by precomposition, $\invim{r} A = A \circ r$. Reindexing is contravariantly functorial,
%
\begin{equation*}
  \invim{\id[I]} A  = A
  \qquad\text{and}\qquad
  \invim{(s \circ r)} A = \invim{r} (\invim{s} A).
\end{equation*}
%
Therefore, families and reindexings form a functor $\opcat{\Set} \to \Cat$.

The two fundamental operations on families of sets are the cartesian products and sums. We require them in a generalized form, where the product and the sum is taken with respect to a reindexing, as follows.
%
Consider $r : J \to I$ and $A \in \Fam{J}$. For $K \subseteq I$ write\sidenote{Careful, the notation $\invim{r}$ is used both for $\invim{r} : \pow{I} \to \pow{J}$ and $\invim{r} : \Fam{I} \to \Fam{J}$. The coincidence is not accidental.} $\invim{r} K = \set{ j \in J \such r j \in K}$, and define the \defemph{product} $\Pi_r A \in \Fam{I}$ and the \defemph{sum} $\Sigma_r A \in \Fam{I}$ by
%
\begin{align}
  \label{eq:pi-r}
  (\Pi_r A)_i &=
    \set{ u : \invim{r} \set{i} \to \textstyle\bigcup_{j \in \invim{r} \set{i}} A_j
            \such \all{j \in \invim{r} \set{i}} u j \in A_j
    }
  \\
  \notag
  (\Sigma_J A)_i &= \set{ (j, x) \such j \in \invim{r} \set{i} \land x \in A_j }.
\end{align}
%
The usual product and sum of a family are recovered when $r : J \to \one$.

\begin{exercise}
  Show that $\Pi_r : \Fam{J} \to \Fam{I}$ is a functor by providing a suitable action on the morphisms, and similarly for $\Sigma_r$.
\end{exercise}

The distinguishing feature of products and sums is that they are adjoint to reindexing,
%
\begin{equation*}
  \Sigma_r \dashv \invim{r} \dashv \Pi_r.
\end{equation*}
%
Concretely, the above amounts to having isomorphisms, natural in $A \in \Fam{J}$ and $B \in \Fam{I}$,
%
\begin{equation*}
  \Hom[\Fam{I}]{\Sigma_r A, B}
  \cong
  \Hom[\Fam{J}]{A, \invim{r} B}
\end{equation*}
%
and
%
\begin{equation*}
  \Hom[\Fam{I}]{B, \Pi_r A}
  \cong
  \Hom[\Fam{J}]{\invim{r} B, A}.
\end{equation*}
%
We spell out the second isomorphism and leave the first one as an exercise.
%
Given $(f_i : B_i \to (\Pi_r A)_i)_{i \in I}$, define $(\hat{f}_j : B_{r j} \to A_j)_{j \in J}$ by $\hat{f}_j x = f_{r j} x j$, and given $(g_j : B_{r j} \to A_j)_{j \in J}$ define $(\check{g}_i : B_i \to (\Pi_r A)_i)_{i \in I}$ by $\check{g}_i x j = g_j x$. It is easy to see that $f \mapsto \hat{f}$ and $g \mapsto \check{g}$ are inverses of each other. Checking naturality is less pleasant but instructive.

\begin{exercise}
  Complete the verification of $\Sigma_r \dashv \invim{r} \dashv \Pi_r$.
\end{exercise}

\subsection{Type theory as the internal language}
\label{sec:interpr-type-theory}

Having identified the relevant set-theoretic structure, we can now interpret the language of type theory in set theory.

\subsubsection{Contexts}
\label{sec:contexts}

In type theory the index sets are called \defemph{contexts}. In practice they are not arbitrary sets (although they can be), but are rather built up by introduction of new parameters in an inductive fashion:
\begin{itemize}
\item the empty context is the singleton\sidenote{A family of sets which does not depend on any parameters is just a fixed set, so an element of $\Fam{\one}$. If you think the empty context should be $\emptyset$, consider what $\Fam{\emptyset}$ is like.} $\emptyCtx = \set{\star}$,
\item given a context $\Gamma$ a family of sets $A \in \Fam{\Gamma}$ and a fresh\sidenote{A variable is \defemph{fresh} if it has not yet been used anywhere else. We can avoid variables names altogether by referring to the components of a context by their positions, a technique known as ``de Bruijn indices''. In practice we prefer to name parameters.} parameter~$x$, the \defemph{extended context} is the set
  %
  \begin{equation*}
    (\Gamma, x \of A) = \set{ (\gamma, a) \such \gamma \in \Gamma \land a \in A_\gamma }.
  \end{equation*}
  %
\end{itemize}
%
By iterating context extension we obtain a \defemph{telescope}
%
\begin{equation*}
  (((\emptyCtx, x_1 \of A_1), x_2 \of A_2), \ldots, x_n \of A_n),
\end{equation*}
%
which we write in flattened form and without parentheses as
%
\begin{equation*}
  x_1 \of A_1, x_2 \of A_2, \ldots, x_n \of A_n.
\end{equation*}
%
It is a set whose elements are tuples\sidenote{To be quite precise, the elements are nested pairs $(((\star, a_1), a_2) \cdots, a_n)$ but we might as well use these as the definition of $n$-tuples $(a_1, \ldots, a_n)$.} $(a_1, \ldots, a_n)$ such that $a_i \in A_{(a_1, \ldots, a_{i-1})}$ for $i = 1, \ldots, n$.
%
Once again, ``context'' is a synonym for ``set'', but in practice we use telescopes.

\begin{example}
  Suppose a mathematical text says
  %
  \begin{quote}
    \emph{``Consider a continuous $f : [a, b] \to \RR$ bounded by $M \in \RR$.''}
  \end{quote}
  %
  What precisely is the context? It is implied that $a, b \in \RR$ and that $a < b$, so
  at first we might think that the context is
  %
  \begin{equation*}
    a \of \RR, \quad
    b \of \RR, \quad
    f \of [a, b] \to \RR, \quad
    M \of \RR.
  \end{equation*}
  %
  We would be led astray by mathematical traditions which demands that proofs and hypotheses be considered second-class entities. Indeed, notice how the text introduces names $a, b, f, M$ for all the entities \emph{except} the assumptions of continuity and boundedness.
  The correct context, written vertically for readability is
  %
  \begin{align*}
    & a : \RR, \\
    & b : \RR, \\
    & p : (a < b), \\
    & f : [a, b] \to \RR, \\
    & q : \mathsf{continuous}(f), \\
    & M : \RR, \\
    & r : \all{x \in [a,b]} f(x) \leq M
  \end{align*}
  %
  However, we now face a difficulty: in what sense are logical formulas, such as $a < b$ and $\mathsf{continuous(f)}$ families of sets? They must be, if they are to appear in contexts. We shall resolve the matter in \cref{propositions-as-types}.
\end{example}

\subsubsection{Type families and their elements}
\label{sec:type-families}

When type theory is used to talk about set theory, we prefer to say \defemph{type} and \defemph{type family} instead of ``set'' and ``set family'', and we even write $\Type{\Gamma}$ instead of $\Fam{\Gamma}$. An alternative notation for $A \in \Fam{\Gamma}$ is
%
\begin{equation*}
  \Gamma \types A \istype.
\end{equation*}
%
A \defemph{choice map} for the family~$A$ is a map $t : \Gamma \to \bigcup_{\gamma \in \Gamma} A_\gamma$ such that $t \gamma \in A_\gamma$ for all $\gamma \in \Gamma$.
We write
%
\begin{equation*}
  \Gamma \types t : A
\end{equation*}
%
when $t$ is such a choice map, and call it an \defemph{element} of~$A$.

\begin{example}
  Let us translate the statement
  %
  \begin{quote}
    \emph{``$(a + b)/2$ is an element of the closed interval $[a,b]$.''}
  \end{quote}
  %
  to the type-theoretic terminology. First, the text expects us to guess that~$a$ and~$b$ are reals such that $a \leq b$, so the context is
  %
  \begin{equation*}
    a \of \RR, b \of \RR, p \of (a \leq b).
  \end{equation*}
  %
  Over this context we define a type family~$C$ of closed intervals by
  %
  \begin{equation*}
    C(a, b, p) = [a, b] = \set{x \in \RR \such a \leq x \leq b}.
  \end{equation*}
  %
  The mid-point is indeed an element of~$C$, i.e., it is the choice map~$m$ for~$C$ defined by $m(a, b, p) = (a + b)/2$.
\end{example}

\subsubsection{Dependent products and sums}
\label{sec:depend-sums-prod-in-sets}

The cartesian product of a family $A : I \to Set$ is the set of all choice maps of~$A$, a familiar definition. However, quite often we need to form the product of a family indexed by several parameters with respect to one of them. We can do so with the help of products along reindexings~\eqref{eq:pi-r}.

Suppose $\Gamma, x \of A \types B \istype$ us a type family over $(\Gamma, x \of A)$.
Let $p : (\Gamma, x \of A) \to \Gamma$ be the first projection $p(\gamma, a) = \gamma$.
Define the \defemph{product} of~$B$ to be the type family $\Gamma \types \Pi_p B \istype$.
Unfolding the definitions shows that, for $\gamma \in \Gamma$,
%
\begin{align*}
  (\Pi_p B)_\gamma &=
  \set{ u : \invim{p} \set{\gamma} \to
        \textstyle\bigcup_{\delta \in \invim{p} \set{\gamma}} B_\delta
    \such \all{\delta \in \invim{p} \set{\gamma}} u \delta \in B_\delta
  } \\
  &\cong
  \set{ u : A_\gamma \to
        \textstyle\bigcup_{a \in A_\gamma} B_{(\gamma, a)}
    \such \all{a \in A_\gamma} u a \in B_{(\gamma, a)}
  },
\end{align*}
%
which is precisely the desired parameterized version of cartesian product.

A similar line of though show that the \defemph{sum} of a family $\Gamma, x \of A \types B \istype$ is the family $\Gamma \types \Sigma_p B$, where $p$ is as above. It is the parameterized version of the disjoint sum, or coproduct, of a family:
%
\begin{align*}
  (\Sigma_p B)_\gamma &=
  \set{ (\delta, b) \such \delta \in \invim{\gamma} \set{\gamma} \land b \in B_\delta }
  \\
  &\cong
  \set{ (a, b) \such a \in A_\gamma \land b \in B_{\gamma, a)}}.
\end{align*}

\begin{exercise}
  Explicitly write down the isomorphisms appearing in the above calculations
  of $\Pi_p B$ and $\Sigma_p B$.
\end{exercise}

\section{Families of assemblies}
\label{sec:families-assemblies}

The interpretation of type theory in sets can be mimicked in assemblies, we only need to make sure that the set-theoretic constructions are realized. However, we must first define what a family of assemblies is.

We could define a family of assemblies simply to be a collection of assemblies indexed by an assembly. This almost works: we additionally require that all the assemblies in the family share the same underlying type.\sidenote{The assemblies must all share the same type because tpcas are simply typed. By having all the assemblies in the family share the same type, we facilitate the construction of its product, whose underlying type may be taken to be a simple function type, see \cref{sec:depend-sums-prod}.}

\begin{definition}
  A \defemph{(uniform) family of assemblies} $S : I \to \AsmA$ is given by an
  \defemph{index assembly~$I$}, an \defemph{underlying type} $\T{S}$, and for each
  $i \in \S{I}$ an assembly $S_i$ such that $\T{S_i} = \T{S}$.
\end{definition}

The qualifier ``uniform'' refers to the fact that all the members share the same underlying type. We drop it because we only ever consider uniform families.
%
We write $\Fam[\AA, \subAA]{I}$ or just $\Fam{I}$ for the collection of all families of assemblies indexed by~$I$. For everything to work out, maps between families of assemblies have to be uniformly realized.

\begin{definition}
  A \defemph{(uniform) map of families} $f : A \to B$ between families of assemblies $A, B \in \Fam{I}$ is given by a family of maps $(f_i : \S{A_i} \to \S{B_i})_{i \in \S{I}}$
  for which there exists $\R{f} \in \subAtyp{\S{I} \to \S{A} \to \S{B}}$ such that,
  for all $i$, $\R{i}$, $x$, $\R{x}$,
  %
  \begin{equation*}
    \R{i} \rz[I] i \land \R{x} \rz[A_i] x \implies \R{f}\,\R{i}\,\R{x} \rz[B_i] f x.
  \end{equation*}
\end{definition}

The definition endows each $\Fam{I}$ with the structure of a category.
%
Reindexing is still precomposition. And assembly map $r : J \to I$ induces a map $\invim{r} : \Fam{I} \to \Fam{J}$, defined by
%
\begin{equation*}
  \invim{r} A = A \circ r.
\end{equation*}
%
There is nothing here to be realized, but we shall use realizers for~$r$ in the construction of products and sums.

\begin{exercise}
  Verify that reindexing is a contravariantly functorial.
\end{exercise}


\subsection{Dependent sums and products}
\label{sec:depend-sums-prod}


Given a uniform family $(S_i)_{i \in I}$, we may form the
\defemph{dependent sum}
%
\begin{equation*}
  \dsum_{i \in I} S_i =
  (\dsum_{i \in I} S_i, \T{I} \times \T{S}, \rz[\dsum_{i \in I S_i}])
\end{equation*}
%
where $\dsum_{i \in I} S_i = \set{(i,x) \such i \in I \land x \in
  S_i}$ is the disjoint sum of the sets $S_i$ and
%
\begin{equation*}
  \combPair\;\R{i}\;\R{x} \rz[\dsum_{i \in I S_i}] (i, x)
  \iff
  \R{i} \rz[I] i
  \land
  x \in S_i
  \land
  \R{x} \rz[S_i] x.  
\end{equation*}
%
Similarly, we may form the \defemph{dependent product} of a uniform
family $(S_i)_{i \in I}$. First recall that the
set-theoretic product of the family of \emph{sets} $(S_i)_{i \in I}$
is
%
\begin{equation*}
  \dprod_{i \in I} S_i =
  \set{f : I \to \tbigcup_{i \in I} S_i \such
    \all{i}{I}{f(i) \in S_i}
  }.
\end{equation*}
%
Let $\rz[\dprod_{i \in I S_i}]$ be the relation between $\Atyp{\T{I}
  \to \T{S}}$ and $\dprod_{i \in I} S_i$, defined by
%
\begin{equation*}
  \R{f} \rz[\dprod_{i \in I S_i}] f
  \iff
  \all{\R{i}}{\Atyp{\T{I}}}{
    \all{i \in I}
      (\R{i} \rz[I] i
      \implies
      \defined{\R{f}\;\R{i}} \land
      \R{f}\;\R{i} \rz[S_i] f(i))
  }.
\end{equation*}
%
Finally, define the dependent product of the family to be the assembly
%
\begin{equation*}
  \dprod_{i \in I} S_i =
  (\set{f \in \dprod_{i \in I} S_i \such
    \some{\R{f}}{\Atyp{\T{I} \to \T{S}}}{\R{f} \rz[\dprod_{i \in I S_i}]
      f}},
  \T{I} \to \T{S}, {\rz[\dprod_{i \in I S_i}]}).
\end{equation*}
%
Notice how at the level of underlying types the dependency on the
parameter~$i$ disappears because we required the families to be
uniform. This is fortunate, as most programming languages are not
equipped with dependent types.

The dependent sums and products have their universal properties which
are somewhat complicated to state. Suffice it to say that they are the
constructions needed to show that $\AsmA$ is \defemph{locally
  cartesian-closed (lccc)}, cf.\ \sidecite{background-lccc}.

\section{Identity types}
\label{sec:identity-types}

\subsection{UIP and equality reflection}
\label{sec:uip-equal-refl}

\subsection{An intensional model}
\label{sec:an-intensional-model}



\section{Inductive and coinductive types}
\label{sec:inductive-counductive-types}


\section{Propositional truncation}
\label{sec:prop-trunc}

\subsection{Logic from type theory}
\label{sec:logic-from-type}

\section{Universes}
\label{sec:universes}

\subsection{Universes of propositions}
\label{sec:universe-propositions}

The universe of decidable propositions.

The universe of semi-decidable propositions.

The universe of stable propositions.

The universe of propositions.

\subsection{The universe of modest sets}
\label{sec:universe-modest-sets}

\subsection{The universe of small assemblies}
\label{sec:univ-small-assembl}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "notes-on-realizability"
%%% End:
