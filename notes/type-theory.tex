\chapter{Realizability and type theory}
\label{cha:type-theory-real}

In everyday mathematics \emph{parametrized} constructions are commonplace. For
example, when a mathematical text says ``consider a continuous map $f
: [a,b] \to \RR$'', there is an
implicit use of the parametrized set $[a,b] = \set{x \in \RR \such a
  \leq x \leq b}$, where $a$ and $b$ are the parameters. 
And whenever in algebra we say ``the cyclic group $\ZZ_n$'', that is not a single group, but a \emph{family} of groups parameterized by $n \in \NN$.

The language of such parameterized constructions is \defemph{(dependent) type theory}. It is applicable in many settings, including realizability. In this chapter we shall give an interpretation of type theory in terms of families of assemblies.


\section{Families of sets}
\label{sec:families-sets}

To set the scene, let us review the set-theoretic model of type theory. A \defemph{family of sets} is a map $A : I \to \Set$ from an \defemph{index set}~$I$ to the class of all sets. We say that \emph{$A$ is indexed by~$I$} or that it is \emph{a family over base~$I$}. Let $\Fam{I}$ be the class of all families indexed by~$I$.

Each $\Fam{I}$ is a category whose objects are the families indexed by~$I$. A morphism $f : A \to B$, where $A, B \in \Fam{I}$, is a \defemph{map of families} $f : A \to B$, which is a family of maps $f_i : A_i \to B_i$, parameterized by $i \in I$. Such maps are composed index-wise.

\begin{exercise}
  Recall the definition of the \defemph{slice category} $\Set/I$: an object is a map $a : A \to I$ with codomain~$I$, and a morphism a map $f : A \to B$ such that $b \circ f = a$:
  %
  \begin{equation*}
    \xymatrix@-1em{
      {A} \ar[rr]^{f}
      \ar[dr]_{a}
      & &
      {B}
      \ar[dl]^{b}
      \\
      & {I}
    }
  \end{equation*}
  %
  A map into~$I$ is called a \defemph{display map} over the \defemph{base~$I$}, and its domain the \defemph{total space}. (The terminology is inspired by a geometric picture of a bundle over a space.)

  For each $i \in I$ we define the \defemph{fiber} of~$a$ at~$i$ to be the inverse image $\invim{a} \set{i} = \set{x \in A \such a x = i}$. Thus a display map~$a$ over~$I$ yields an $I$-indexed family $i \mapsto \invim{a} \set{i}$ of fibers.
  %
  Conversely, a family $A : I \to \Set$ determines the display map, namely the first projection $\Sigma_I A \to I$.

  Verify that the passages between $\Fam{I}$ and $\Set/I$ constitute an equivalence of categories. As a first step you should determine how the equivalence acts on morphisms.
\end{exercise}

A map $r : J \to I$, induces \defemph{reindexing} $\invim{r} : \Fam{I} \to \Fam{J}$ by precomposition, $\invim{r} A = A \circ r$. Reindexing is contravariantly functorial,
%
\begin{equation*}
  \invim{\id[I]} A  = A
  \qquad\text{and}\qquad
  \invim{(s \circ r)} A = \invim{r} (\invim{s} A).
\end{equation*}
%
Therefore, families and reindexings form a functor $\opcat{\Set} \to \Cat$.

\subsection{Products and sums of families of sets}
\label{sec:prod-sums-sets}

The two fundamental operations on families of sets are the cartesian products and sums. 
Given a family $A \in \Fam{I}$, its \defemph{product} $\Pi_I A$ and \defemph{sum} $\Sigma_I A$ are respectively the sets
%
\begin{align*}
  \Pi_I A &= 
  \textstyle
  \set{ u : I \to \bigcup_{i \in I} A_i \such \all{i \in I} u i \in A_i }, \\
  \Sigma_I A &= \set{ (i, a) \such i \in I \land a \in A_i }.
\end{align*}
%
The elements of the product are called \defemph{choice maps}.

We shall need their generalized forms, where the product and the sum is taken with respect to a reindexing, as follows.
%
Consider $r : J \to I$ and $A \in \Fam{J}$. For $K \subseteq I$ write\sidenote{Careful, the notation $\invim{r}$ is used both for $\invim{r} : \pow{I} \to \pow{J}$ and $\invim{r} : \Fam{I} \to \Fam{J}$. The coincidence is not accidental.} $\invim{r} K = \set{ j \in J \such r j \in K}$, and define the \defemph{product} $\Pi_r A \in \Fam{I}$ and the \defemph{sum} $\Sigma_r A \in \Fam{I}$ by
%
\begin{align}
  \label{eq:pi-r}
  (\Pi_r A)_i &=
    \set{ u : \invim{r} \set{i} \to \textstyle\bigcup_{j \in \invim{r} \set{i}} A_j
            \such \all{j \in \invim{r} \set{i}} u j \in A_j
    }
  \\
  \notag
  (\Sigma_J A)_i &= \set{ (j, x) \such j \in \invim{r} \set{i} \land x \in A_j }.
\end{align}
%

\begin{exercise}
  Show that $\Pi_r : \Fam{J} \to \Fam{I}$ is a functor by providing a suitable action on the morphisms, and similarly for $\Sigma_r$.
\end{exercise}





The distinguishing feature of products and sums is that they are adjoint to reindexing,
%
\begin{equation*}
  \Sigma_r \dashv \invim{r} \dashv \Pi_r.
\end{equation*}
%
Concretely, the above amounts to having isomorphisms, natural in $A \in \Fam{J}$ and $B \in \Fam{I}$,
%
\begin{equation*}
  \Hom[\Fam{I}]{\Sigma_r A, B}
  \cong
  \Hom[\Fam{J}]{A, \invim{r} B}
\end{equation*}
%
and
%
\begin{equation*}
  \Hom[\Fam{I}]{B, \Pi_r A}
  \cong
  \Hom[\Fam{J}]{\invim{r} B, A}.
\end{equation*}
%
We spell out the second isomorphism and leave the first one as an exercise.
%
Given a map of families $f : B \to \Pi_r A$, define $\hat{f} : \invim{r} B \to A$ by
%
\begin{equation}
  \label{eq:sub-adj-pi-hat}
  \hat{f}_j x = f_{r j} x j,
\end{equation}
%
and given $g : \invim{r} B \to A$ define $\check{g} : B \to \Pi_r A$ by 
%
\begin{equation}
  \label{eq:sub-adj-pi-check}
  \check{g}_i x j = g_j x.
\end{equation}
%
It is easy to see that $f \mapsto \hat{f}$ and $g \mapsto \check{g}$ are inverses of each other. Checking naturality is less pleasant but instructive.

\begin{exercise}
  Complete the verification of $\Sigma_r \dashv \invim{r} \dashv \Pi_r$.
\end{exercise}

\subsection{Type theory as the internal language}
\label{sec:interpr-type-theory}

Having identified the relevant set-theoretic structure, we can now interpret the language of type theory in set theory.

\subsubsection{Contexts}
\label{sec:contexts}

In type theory the index sets are called \defemph{contexts}. In practice they are not arbitrary sets (although they can be), but are rather built up by introduction of new parameters in an inductive fashion:
%
\begin{itemize}
\item the empty context is the singleton\sidenote{A family of sets which does not depend on any parameters is just a fixed set, so an element of $\Fam{\one}$. If you think the empty context should be $\emptyset$, consider what $\Fam{\emptyset}$ is like.} $\emptyCtx = \set{\star}$,
\item given a context $\Gamma$ and a family of sets $A \in \Fam{\Gamma}$, the \defemph{extended context} is the sum $\Sigma_\Gamma A$.
\end{itemize}

By iterating context extension we obtain a \defemph{telescope}
%
\begin{equation*}
  \Sigma_{\Sigma_{\cdots \Sigma_{\Sigma_{\emptyCtx} \cdots} A_{n-2}} A_{n-1}} A_n.
\end{equation*}
%
Such a nested sum is unwieldy, so we write it as
%
\begin{equation*}
  x_1 \of A_1, x_2 \of A_2, \ldots, x_n \of A_n.
\end{equation*}
%
where $x_1, \ldots, x_n$ are distinct variable names. This way we may access the components of the telescope by referring to the variables, rather than having to use iterated projections.
%
The elements of a telescope are tuples\sidenote{To be quite precise, the elements are nested pairs $(((\star, a_1), a_2) \cdots, a_n)$ but we might as well use these as the definition of $n$-tuples $(a_1, \ldots, a_n)$.} $(a_1, \ldots, a_n)$ such that $a_i \in A_{(a_1, \ldots, a_{i-1})}$ for $i = 1, \ldots, n$.
%
Once again, ``context'' is a synonym for ``set'', but in practice we use telescopes.

\begin{example}
  \label{example:context}
  %
  Suppose a mathematical text says
  %
  \begin{quote}
    \emph{``Consider a continuous $f : [a, b] \to \RR$ bounded by $M \in \RR$.''}
  \end{quote}
  %
  What precisely is the context? It is implied that $a, b \in \RR$, so at first we might think that the context is
  %
  \begin{equation*}
    a \of \RR, \quad
    b \of \RR, \quad
    f \of [a, b] \to \RR, \quad
    M \of \RR.
  \end{equation*}
  %
  However, there are also three \emph{hypotheses}, namely that $a < b$, that $f$ is continuous, and that~$f$ is bounded by~$M$.
  %
  Mathematical tradition would have us ignore these, because it demands that proofs and logical statements be considered second-class. Indeed, notice how the text introduces names $a, b, f, M$ for all the entities \emph{except} the hypotheses, and even these notes refer to theorems by mere unmemorable numbers, as if it were forbidden to name them.
  %
  The correct context is, written vertically for readability,
  %
  \begin{align*}
    & a : \RR, \\
    & b : \RR, \\
    & p : (a < b), \\
    & f : [a, b] \to \RR, \\
    & q : \mathsf{continuous}(f), \\
    & M : \RR, \\
    & r : \all{x \in [a,b]} f(x) \leq M
  \end{align*}
  %
  However, we now face a difficulty: in what sense are logical formulas, such as $a < b$ and $\mathsf{continuous(f)}$ families of sets? They must be, if they are to appear in contexts. We shall resolve the matter in \cref{{sec:prop-trunc}}.
\end{example}

\subsubsection{Type families and their elements}
\label{sec:type-families}

When type theory is used to talk about set theory, we prefer to say \defemph{type} and \defemph{type family} instead of ``set'' and ``set family'', and write
%
\begin{equation*}
  \Gamma \types A \istype
\end{equation*}
%
for $A \in \Fam{\Gamma}$.
%
The \defemph{elements} of~$A$ are its choice maps. We write
%
\begin{equation*}
  \Gamma \types t : A
\end{equation*}
%
when $t$ is such a choice map.

\begin{example}
  To see why it makes sense to call the choice maps ``elements'',
  we translate the statement
  %
  \begin{quote}
    \emph{``$(a + b)/2$ is an element of the closed interval $[a,b]$.''}
  \end{quote}
  %
  to the type-theoretic terminology. First, the text expects us to guess that~$a$ and~$b$ are reals such that $a < b$, so the context is
  %
  \begin{equation*}
    a \of \RR,\quad b \of \RR,\quad p \of (a < b).
  \end{equation*}
  %
  Over this context we define a type family~$C$ of closed intervals by\sidenote{Dragging along the argument~$p$ seems a little bureaucratic. In practice we would of course drop it, and in a proof assistant we might use one of several mechanisms that hide it.}
  %
  \begin{equation*}
    C_{(a, b, p)} = [a, b] = \set{x \in \RR \such a \leq x \leq b}.
  \end{equation*}
  %
  The mid-point is map~$m$ which assigns to each interval its mid-point, $m(a, b, p) = (a + b)/2$, which of course is just a choice map for~$C$.
\end{example}

\subsubsection{Dependent products and sums}
\label{sec:depend-sums-prod-in-sets}

If a family is indexed by a telescope with parameters $x_1, \ldots, x_n$, we may wish to form the cartesian product with respect to just~$x_n$,
which is accomplished by taking the product~\eqref{eq:pi-r} along a suitable reindexing.
%
Suppose $\Gamma, x \of A \types B \istype$ and let $p : (\Gamma, x \of A) \to \Gamma$ be the first projection $p(\gamma, a) = \gamma$.
%
Define the \defemph{product} of~$B$ to be the type family $\Gamma \types \Pi_p B \istype$.
Unfolding the definitions shows that, for $\gamma \in \Gamma$,
%
\begin{align*}
  (\Pi_p B)_\gamma &=
  \set{ u : \invim{p} \set{\gamma} \to
        \textstyle\bigcup_{\delta \in \invim{p} \set{\gamma}} B_\delta
    \such \all{\delta \in \invim{p} \set{\gamma}} u \delta \in B_\delta
  } \\
  &\cong
  \set{ u : A_\gamma \to
        \textstyle\bigcup_{a \in A_\gamma} B_{(\gamma, a)}
    \such \all{a \in A_\gamma} u a \in B_{(\gamma, a)}
  },
\end{align*}
%
which is precisely the desired parameterized version of cartesian product.

A similar line of though show that the \defemph{sum} of a family $\Gamma, x \of A \types B \istype$ is the family $\Gamma \types \Sigma_p B$, where $p$ is as above. It is the parameterized version of the disjoint sum, or coproduct, of a family:
%
\begin{align*}
  (\Sigma_p B)_\gamma &=
  \set{ (\delta, b) \such \delta \in \invim{\gamma} \set{\gamma} \land b \in B_\delta }
  \\
  &\cong
  \set{ (a, b) \such a \in A_\gamma \land b \in B_{(\gamma, a)}}.
\end{align*}

\begin{exercise}
  Explicitly write down the isomorphisms appearing in the above calculations
  of $\Pi_p B$ and $\Sigma_p B$. Does it matter which of the two isomorphic versions of products and sums we use?
\end{exercise}

\section{Families of assemblies}
\label{sec:families-assemblies}

The interpretation of type theory in assemblies proceeds much as in sets, we only need to make sure that the set-theoretic maps are realized. However, we must first define what a family of assemblies is.

Defining a family of assemblies to be a collection of assemblies indexed by (the underlying set of) an assembly almost works, we just have to additionally require that all the assemblies in the family share the same underlying type.\sidenote{This is so because tpcas are simply typed. By making all the assemblies in the family share the same type, we facilitate the construction of its product, whose underlying type may then be the (non-dependent) function type, see \cref{sec:depend-sums-prod}.}

\begin{definition}
  A \defemph{(uniform) family of assemblies} $S : I \to \AsmA$ is given by an
  \defemph{index assembly~$I$}, an \defemph{underlying type} $\T{S}$, and for each
  $i \in \S{I}$ an assembly $S_i$ such that $\T{S_i} = \T{S}$.
\end{definition}

The qualifier ``uniform'' refers to the fact that all the members share the same underlying type. We drop it because we only ever consider uniform families.
%
We write $\Fam[\AA, \subAA]{I}$ or just $\Fam{I}$ for the collection of all families of assemblies indexed by~$I$. For everything to work out, maps between families of assemblies have to be uniformly realized.

\begin{definition}
  A \defemph{(uniform) map of families} $f : A \to B$ between families of assemblies $A, B \in \Fam{I}$ is given by a family of maps $(f_i : \S{A_i} \to \S{B_i})_{i \in \S{I}}$
  for which there exists $\R{f} \in \subAtyp{\S{I} \to \S{A} \to \S{B}}$ such that,
  for all $i$, $\R{i}$, $x$, $\R{x}$,
  %
  \begin{equation*}
    \R{i} \rz[I] i \land \R{x} \rz[A_i] x \implies \R{f}\,\R{i}\,\R{x} \rz[B_i] f x.
  \end{equation*}
\end{definition}

The definition endows each $\Fam{I}$ with the structure of a category.
%
An assembly map $r : J \to I$ induces a \defemph{reindexing} $\invim{r} : \Fam{I} \to \Fam{J}$, defined by
%
\begin{equation*}
  \invim{r} A = A \circ r.
\end{equation*}
%
There is nothing here to be realized, but we shall use realizers for~$r$ in the construction of products and sums.

\begin{exercise}
  Verify that reindexing is contravariantly functorial.
\end{exercise}


\subsection{Products and sums of families of assemblies}
\label{sec:depend-sums-prod-asm}

Consider a family of assemblies $S \in \Fam{I}$. It has an underlying family of sets $\S{S} \in \Fam{I}$, defined by $i \mapsto \S{S_i}$. Given an assembly map $r : J \to I$
and $i \in \S{I}$, say that $u \in \Pi_r \S{S}$ is \defemph{realized} by $\R{u} \in \Atyp{\T{J} \to \T{S}}$ when, for all $j \in \invim{r} \set{i}$ and $\R{j} \in \Atyp{\T{J}}$,
%
\begin{equation*}
  \R{j} \rz[J] j \implies
  \R{u}\,\R{j} \rz[S_i] u j.
\end{equation*}
%
When this is the case, we write $\R{u} \rz[\Pi_r S] u$.
%
Now define the \defemph{product} $\Pi_r S \in \Fam{J}$ to be the family whose realizability relation is~$\rz[\Pi_r S]$ and
%
\begin{align*}
  \T{\Pi_r S} &= \T{J} \to \T{S}, \\
  \S{\Pi_r S} &= 
    \set{ u \in \Pi_r \S{S} \such
       \some{\R{u} \in \Atyp{\T{J} \to \T{S}}} \R{u} \rz[\Pi_r S] u
    }.
\end{align*}
%
Define the \defemph{sum} $\Sigma_r S \in \Fam{J}$ to be the family
%
\begin{align*}
  \T{\Sigma_r S} &= \T{J} \times \T{S}, \\
  \S{\Sigma_r S} &= \Sigma_r \S{S}, \\
  \R{r} \rz[\Sigma_r S] (j, x) &\liff
  \combFst\,\R{r} \rz[J] j \land \combSnd\,\R{r} \rz[S_j] x.
\end{align*}
%
Notice how at the level of underlying types the dependency on the
parameter disappears because we required the families to be
uniform.

\begin{exercise}
  Verify the adjunctions
  %
  \begin{equation*}
    \Sigma_r \dashv \invim{r} \dashv \Pi_r.
  \end{equation*}
  %
  Half of work has been done in \cref{sec:prod-sums-sets}.
  You still need to check that the map of families $\hat{f}$ defined in~\eqref{eq:sub-adj-pi-hat} is realized when~$f$ is realized, and similarly for $\check{g}$ defined in~\eqref{eq:sub-adj-pi-check}.
\end{exercise}

Products and sums along arbitrary reindexings are perhaps a bit unintuitive. For better understanding we spell out the non-parameterize sum and products.

Given a family $S \in \Fam{I}$, its \defemph{product} $\Pi_I S$ is the assembly
%
\begin{align*}
  \T{\Pi_I S} &= \T{I} \to \T{S}, \\
  \S{\Pi_I S} &= \textstyle
     \set{u \in \Pi_{\S{I}} \S{S} \such
          \some{\R{u} \in \Atyp{\T{I} \to \T{S}}} \R{u} \rz[\Pi_I S] u
     },\\
  \R{u} \rz[\Pi_I S] u &\liff
  \all{i \in \S{I}, \R{i} \in \Atyp{\T{I}}}
    \R{i} \rz[I] i \lthen \R{u}\,\R{i} \rz[S_i] u i.
\end{align*}
%
The \defemph{sum} $\Sigma_I S$ is the assembly
%
\begin{align*}
  \T{\Sigma_I S} &= \T{I} \times \T{S}, \\
  \S{\Sigma_I S} &= \Sigma_{\S{I}} \S{S}, \\
  \R{r} \rz[\Sigma_I S] (i, x) &\liff
    \combFst\,\R{r} \rz[I] i \land
    \combSnd\,\R{r} \rz[S_i] x.
\end{align*}
%
These are indeed just the familiar set-theoretic constructions embellished with realizers.

\subsection{Contexts of assemblies}
\label{sec:contexts-assemblies}

Contexts of assemblies are built the same was as contexts of sets, as iterated sums.
Thus a telescope
%
\begin{equation*}
  \Gamma = (x_1 : S_1, \ldots, x_n : S_n)
\end{equation*}
%
is the assembly
%
\begin{align*}
  \T{\Gamma} &= \T{S_1} \times \cdots \times \T{S_n}, \\
  \S{\Gamma} &= \set{(a_1, \ldots, a_n) \such \all{i \leq n} a_i \in \S{(S_i)_{(a_1, \ldots, a_{i-1})}}} \\
  \R{r} \rz[\Gamma] (a_1, \ldots, a_n)
  &\liff
  \all{i \leq n} \pcacomb{proj}_{n,i}\,\R{r} \rz[(S_i)_{(a_1, \ldots, a_{i-1})}] a_i,
\end{align*}
%
where $\pcacomb{proj}_{n,i}$ is the $i$-th projection from an $n$-tuple.

\section{Propositions and propositional truncation}
\label{sec:prop-trunc}




\section{Identity types}
\label{sec:identity-types}

\subsection{UIP and equality reflection}
\label{sec:uip-equal-refl}

\subsection{An intensional model}
\label{sec:an-intensional-model}



\section{Inductive and coinductive types}
\label{sec:inductive-counductive-types}


\subsection{Logic from type theory}
\label{sec:logic-from-type}

\section{Universes}
\label{sec:universes}

\subsection{Universes of propositions}
\label{sec:universe-propositions}

The universe of decidable propositions.

The universe of semi-decidable propositions.

The universe of stable propositions.

The universe of propositions.

\subsection{The universe of modest sets}
\label{sec:universe-modest-sets}

\subsection{The universe of small assemblies}
\label{sec:univ-small-assembl}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "notes-on-realizability"
%%% End:
