\chapter{Realizability}
\label{chap:realizability}

\section{Basic definitions}
\label{sec:basic-definitions}

\subsection{Motivation and the basic idea}
\label{sec:realizability-basic-idea}

Realizability was introduced by Stephen Kleene~\cite{KleeneSC:intint}
who used it to build a model of intuitionistic arithmetic. Our purpose
is to study not only the theoretical aspects of computable
mathematics, but also practical issues. Thus we approach realizability
by asking a practical question: given a mathematical structure
(constants, functions, relations, and axioms), what should a computer
implementation look like? For simple cases, the answer is obvious. A
group would have a type whose values represent group elements, a value
representing the neutral element, and functions which compute the
group operation and inverses. But for more interesting structures,
especially those arising in mathematical analysis, the answer is less
clear. How do we implement the real numbers (and we do not mean
floating-point arithmetic, we mean the \emph{real} real numbers)?
Which operations on a compact metric space can be implemented? How do
we implement a space of smooth functions? Significant research goes
into finding satisfactory answers to such
questions~\cite{Wei00,TZ98,Bla97}.

To explain the basic idea behind realizability we consider a small
real-world programming example. Suppose we are asked to design a data
structure for the set $\mathsf{Graphs}$ of all finite
simple\footnote{Simple means at most one arrow between any two
  vertices.} directed graphs with vertices labeled by distinct
integers. An typical such graph~$G$ is shown in
Figure~\ref{fig:digraph}.
%
\begin{figure}[htp]
  \centering
  \includegraphics[width=0.3\textwidth]{digraph}
  \caption{A finite directed graph $G$}
  \label{fig:digraph}
\end{figure}
%
One common representation of such graphs uses a pair of lists
$(\ell_V, \ell_A)$, where $\ell_V$ is the list of vertex labels and
$\ell_A$ is the \emph{adjacency list} representing the arrows by
pairing the labels of each source and target. For the above graph $G$,
$\ell_V = [1, 2, 3, 4]$ and $\ell_A = [(1,2), (2,2), (2,3), (3,2),
(3,1)]$.
%
Thus we define the datatype of graphs as\footnote{We use Haskell
  notation in which $[t]$ is the type of lists of elements of
  type~$t$, and $(t_1, t_2)$ is the cartesian product of types~$t_1$
  and~$t_2$.}
%
\begin{lstlisting}[language=Haskell]
type Graph = ([Int], [(Int, Int)])
\end{lstlisting}
%
However, this is not a complete description of the intended
representation, as there are representation invariants and conditions
not expressed by the type, e.g.,
%
\begin{enumerate}
\item The order in which vertices and arrows are listed is not
  important%
; for example, $[1,2,3,4]$ and $[4,1,2,3]$ represent the same vertices.
\item Each vertex and arrow must be listed exactly once.
\item The source and target of each arrow must appear in the list of vertices.
\end{enumerate}
%
Consequently, to fully implement the mathematical
set~$\mathsf{Graphs}$ we must not only decide on the underlying
datatype $\mathtt{graph}$, but also determine what values of that type
represent which elements of~$\mathsf{Graphs}$. All this can be
expressed with a \emph{realizability relation}
%
\begin{equation*}
  r \rz x
\end{equation*}
%
which is read as ``$r$ realizes $x$''. In the above example we would
write
%
\begin{equation*}
([1, 2, 3, 4], [(1,2), (2,2), (2,3), (3,2), (3,1)]) \rz G.
\end{equation*}
%
Once the set $\mathsf{Graphs}$ is implemented as a datatype, an
obvious thing to do is to compute with it. When can we say that a
function $f : \mathsf{Graphs} \to \mathsf{Graphs}$ is computable? The
answer again is quite natural for a programmer: $f$ is computed by a
program $p : \mathtt{graph} \to \mathtt{graph}$ when $p$ does to
realizers what $f$ does to elements: if $r \rz G$ then $p(r) \rz
f(G)$. We say that the map $f$ is \emph{realized} or \emph{tracked} by
the program~$p$.


\subsection{Assemblies}
\label{sec:assemblies}

We now give a precise definition of the ideas presented in the
previous section.

\begin{definition}[Assemblies]
  Let $A$ be a TPCA and $\comp{A}$ a sub-TPCA. An \emph{assembly}
  over~$(A, \comp{A})$ is a triple $(S, |S|, {\rz_S})$ where $S$ is a
  set, $|S|$ is a type, and $\rz_S$ is a relation between $A_{|S|}$
  and~$S$ satisfying: for every $x \in S$ there is $r \in A_{|S|}$
  such that $r \rz_S x$.

  A \emph{realized map} $f : S \to T$ between assemblies $(S, |S|,
  {\rz_S})$ and $(T, |T|, {\rz_T})$ is a map for which there exists $p
  \in \comp{A}_{|S| \to |T|}$ satisfying: if $r \rz_S x$ then $\defined{p
    \cdot r}$ and $p \cdot r \rz_T f(x)$.
\end{definition}

\noindent
By a traditional abuse of notiation we shall often denote an assembly
$(S, |S|, {\rz_S})$ simply as~$S$.

There are many versions of realizability. Ours is known as \emph{typed
  relative realizability}. It is typed because we used typed PCAs
rather than the ordinary ones. It is relative because we used one
TPCA~$A$ for assemblies, and another for the realized maps. By this we
are capturing the idea that computable functions may operate on
potentially non-computable data, as was the case for type~2 machines
and the graph model, cf.\ Sections~\ref{sec:type-2}
and~\ref{sec:graph-model}. In the typical case the larger TPCA~$A$
allows representation of arbitrary data, but the sub-TPCA $\comp{A}$
consists only of the computable part of~$A$ which forces the realizers
for maps to be computable. Thus it makes sense to say in the general
case that the maps are realized \emph{relative} to the choice of a
sub-TPCA~$\comp{A}$.

When $A$ is not typed the definition of an assembly simplifies a bit
because we need not keep mentioning the (trivial) types: an assembly
over a PCA~$A$ is a pair $(S, {\rz_S})$ where $S$ is a set and $\rz_S$
is a relation between~$A$ and~$S$, such that for every $x \in S$ there
is $r \in A$ and $r \rz_S x$.

Another special case occurs when $\comp{A} = A$. In this case we write
$\Asm{A}$ instead of $\Asm{A,A}$.

In most examples the TPCA $A$ is actually an NR-TPCA, and $\comp{A}$ a
sub-NR-TPCA of~$A$.

\begin{proposition}
  Assemblies and realized maps form the \emph{category
    $\Asm{A,\comp{A}}$ of assemblies over $(A, \comp{A})$}.
\end{proposition}

\begin{proof}
  If $f : S \to T$ and $g : T \to U$ are realized by $q \in A_{|S| \to
    |T|}$ and $r \in A_{|T| \to |U|}$, respectively, then their
  composition $g \circ f$ is realized by
  $\pcalam{\annot{x}{|S|}}{r\,(q\,x)} =
  \combS\,(\combK\,r)\,(\combS\,(\combK\,q)\,(\combS\,\combK\,\combK))$.
  The identity map $\id_S : S \to S$ is realized by
  $\pcalam{\annot{x}{|S|}}{x} = \combS\,\combK\,\combK$. Composition
  is associative because it is just composition of maps.
\end{proof}

A common way to get isomorphic assemblies is the following.

\begin{lemma}
  \label{lemma:iso-assembly}
  %
  Suppose $(S, |S|, {\rz_S})$ is an assembly, $T$ is a set, and $f : T
  \to S$ is a bijection. Then $(S, |S|, {\rz_S})$ is isomorphic to
  $(T, |S|, {\rz_T})$ where $r \rz_T x$ is defined as $r \rz_S f(x)$.
\end{lemma}

\begin{proof}
  The map $f$ is a morphism from $(S, |S|, {\rz_S})$ to $(T, |S|,
  {\rz_T})$ because it is tracked by~$\pcalam{\annot{x}{|S|}}{x}$.
  Similarly, $\inv{f}$ is a morphism because it is also tracked by the
  same realizer. Obviously, $f$ and $\inv{f}$ are inverses of each
  other.
\end{proof}


\subsection{Modest sets}
\label{sec:modest-sets}

Suppose $(S, |S|, {\rz_S})$ is an assembly over $(A, \comp{A})$. The
only requirement for the realizability relation $\rz_S$ is that every
$x \in S$ be realized by some $r \in A_{|S|}$. In particular,
different elements $x, y \in S$ may share the same realizer $r \in
A_{|S|}$. It is often reasonable to prohibit such anomalies.

\begin{definition}
  An assembly $(S, |S|, {\rz_S})$ is \emph{modest} when each $r \in
  A_{|S|}$ realizes at most one element of~$S$. A modest assembly is
  also called a \emph{modest set}.
\end{definition}

\noindent
In symbols, modesty is the property
%
\begin{equation*}
  \xall{r}{A_{|S|}}{
    \all{x,y}{S}{
      r \rz_S x \land r \rz_S y \implies x = y
    }
  }.
\end{equation*}
%
The full subcategory of $\Asm{A,\comp{A}}$ of the modest sets is
denoted by~$\Mod{A, \comp{A}}$. The terminology was suggested by Dana
Scott, and modesty refers to the fact that the cardinality of a
modest~$S$ set does not exceed the cardinality of $A_{|S|}$.

Most structures in computable mathematics turn out to be modest.
However, sometimes assemblies are needed, especially when we talk
about multi-valued maps and hyperspaces,
cf.~Sections~\ref{sec:multi-valued-functions}
and~\ref{sec:hyperspaces}.


\subsection{Constant assemblies}
\label{sec:nabla}

The extreme case of elements sharing the same realizer happens when
all elements of a set share all realizers. Assemblies with this
property are called \emph{constant assemblies}. They give us a way of
representing arbitrary sets.

Let $t$ be a type such that $A_t$ is inhabited. Such a type always
exists, because there is at least one type $s$, and then $t = s \to s
\to s$ contains $\combK_{s,s}$. Given any set $X$, let $\nabla X = (X,
t, {\rz_{\nabla X}})$ be the assembly whose underlying set is~$X$ and
the realizability relation is trivial, i.e., $r \rz_{\nabla X} x$ for
all $x \in X$ and $r \in A_t$. If $f : X \to Y$ is any map between
sets~$X$ and~$Y$ then~$f$ is a morphism $\nabla f : \nabla X \to
\nabla Y$ because it is tracked by $\pcalam{\annot{x}{t}}{x}$. This
defines a functor
%
\begin{equation*}
  \nabla : \Set \to \Asm{A,\comp{A}}.
\end{equation*}
%
Up to natural isomorphism, $\nabla$ is independent of the choice of
type~$t$. We will study the properties of $\nabla$ later on. For now
we notice that $\nabla$ is full and faithful, which means that
$\Asm{A,\comp{A}}$ contains the category of sets as a full
subcategory.

The functor $\nabla$ is devoid of any computational content because it
represents a set~$X$ by a trivial realizability relation which conveys
no information at all about the elements of~$X$. Consequently, from
the realizers we cannot compute anything interesting regarding~$X$.


\section{Equivalent formulations}
\label{sec:equivalent-formulations}


Assemblies and modest sets have several equivalent formulations, which
appeared historically as special cases of our definitions.


\subsection{Existence predicates}
\label{sec:existence-predicates}

A realizability relation $\rz_S$, which is a subset of $A_{|S|} \times
S$ may be equivalently expressed as a map $\Ex_S : S \to
\pow{A_{|S|}}$. The correspondence is
%
\begin{equation*}
  r \rz_S x \iff r \in \Ex_S(x).
\end{equation*}
%
Because every $x$ is realized by something, $\Ex_S(x)$ always contains
at least one element. Thus an assembly $(S, |S|, {\rz_S})$ may be
equivalently presented as a triple $(S, |S|, \Ex_S)$ where $\Ex_S : S
\to \pow{A_{|S|}}$ is a map such that $\Ex_S(x)$ contains at least one
element for every $x \in S$. The map $\Ex_S$ is called \emph{existence
predicate} because we can think of the realizers $\Ex_S(x)$ as
computational witnesses for ``existence of~$x$''.

An assembly $S$ is modest if, and only if, $\Ex_S(x) \cap \Ex_S(y)
\neq \emptyset$ implies $x = y$.

Under this formulation a map $f : S \to T$ is realized if there exists
$p \in A_{|S| \to |T|}$ such that, for all $x \in S$ and $r \in
\Ex_S(x)$, $\defined{p\,r}$ and $p\,r \in \Ex_T(f(x))$.

\subsection{Representations}
\label{sec:representations}

By turning the existence predicate around we obtain
\emph{representations}. Suppose first that $S$ is a modest set. Since
every realizer $r \in A_{|S|}$ realizes at most one $x \in S$, we may
define a partial map $\delta_S : A_{|S|} \parto S$ by
%
\begin{equation*}
  \delta_S(x) = r \iff r \rz_S x.
\end{equation*}
%
The map $\delta_S$ is surjective because every $x \in S$ is realized,
but it need not be defined everywhere. The triple $(S, |S|, \delta_S)$
uniquely describes the modest set~$S$. The map $\delta_S$ is called a
\emph{representation} of~$S$.

A map $f : S \to T$ is realized or tracked by $p \in \comp{A}_{|S| \to
  |T|}$ when, for all $r \in \dom(\delta_S)$, $\defined{p\,r}$ and
$\delta_T(p\,r) = f(\delta_S(r))$.

The category of representations and realized maps is denoted
by~$\Rep{A,\comp{A}}$. It is of course equivalent to $\Mod{A,
  \comp{A}}$, but sometimes we want to make the distinction and so we
give it a symbol.

A general assembly $S$ may also be expressed as a representation, if
we allow $\delta_S$ to be a multi-valued partial surjection $\delta_S
: A_{|S|} \multito S$. The relationship between the realizaiblity
relation $\rz_S$, the existence predicate $\Ex_s$ and the
representation $\delta_S$ is
%
\begin{equation*}
  r \rz_S x \iff
  r \in \Ex_S(x) \iff
  x \in \delta_S(r).
\end{equation*}


\subsection{Partial equivalence relations}
\label{sec:pers}

This formulation only works for modest sets, not for general
assemblies. With each modest set~$S$ we may associate a partial
equivalence relation (per)\footnote{A partial equivalence relation is
  a relation which is transitive and antisymmetric.} $\per_S$ on
$A_{|S|}$ which realizes~$q$ and~$r$ when they realize the same
element:
%
\begin{equation*}
  q \per_S r \iff
  \xsome{x}{S}{q \rz_S x \land r \rz_S x}.
\end{equation*}
%
The pair $(|S|, {\per_S})$ suffices for the reconstruction of the
original modest set, up to isomorphism. Let us be a bit more precise
about this.

Let $A$ be a TPCA and $\comp{A}$ a sub-TPCA. A \emph{partial
  equivalence relation} on~$A$ is a pair $S = (|S|, {\per_S})$ where
$|S|$ is a type and $\per_S$ is a transitive and antisymmetric
relation on $A_{|S|}$. A realizer $r \in A_{|S|}$ is \emph{total} if
$r \per_S r$. The set of total realizers is denoted by $\|S\| = \set{r
  \in A_{|S|} \such r \per_S r}$. Each $r \in \|S\|$ is a member of
its equivalence class $[r]_S = \set{q \in A_{|S|} \such r \per_S q}$.

An \emph{extensional realizer} between pers $S$ and $T$ is $p \in
\comp{A}_{|S| \to |T|}$ such that, for all $q, r \in A_{|S|}$, if $q
\per_S r$ then $\defined{p\,q}$, $\defined{p\,r}$, and $p\,q \per_T
p\,r$. Extensional realizers $p$ and $p'$ are \emph{equivalent} when
$q \per_S r$ implies $p\,q \per_T p'\,r$.

Pers and extensional maps form a category $\Per{A, \comp{A}}$ whose
objects are pers on~$A$ and morphisms are equivalence classes of
extensional realizers. The composition of $[p] : S \to T$ and $[q] : T
\to U$ is $[q \circ p] : S \to U$ where $q \circ p =
\pcalam{\annot{x}{|S|}}{q\,(p\,x)}$. The identity morphism $\id_S : S
\to S$ is represented by $\pcalam{\annot{x}{|S|}}{x}$. It is easy to
check that this forms a category.

Let $S$ and $T$ be pers over $(A, \comp{A})$. A morphism $[p] : S \to
T$ may be alternatively described as a function $f : \|S\|/{\per_S}
\to \|T\|/{\per_T}$ which maps an equivalence class $[r]_S$ to the
equivalence class $f([r]) = [p\,r]_T$.

\begin{proposition}
  The categories $\Mod{A, \comp{A}}$ and $\Per{A, \comp{A}}$ are
  equivalent.
\end{proposition}

\begin{proof}
  A modest set $(S, |S|, {\rz_S})$ determines a per $(S, {\per_S})$,
  as described above. A morphism $f : S \to T$ which is tracked by $p
  \in \comp{A}_{|S| \to |T|}$ determines a morphism of pers $[p] : (S,
  {\per_S}) \to (T, {\per_T})$. This defines a functor $F : \Mod{A,
    \comp{A}} \to \Per{A, \comp{A}}$.

  In the other direction the functor $G : \Per{A, \comp{A}} \to
  \Mod{A, \comp{A}}$ sends a per $(|T|, {\per_T})$ to the modest set
  $(\|T\|/{\per_T}, |T|, {\rz_T})$ whose realizability relation is
  %
  \begin{equation*}
    r \rz_T [q] \iff r \per_T q.
  \end{equation*}
  %
  A morphism $[p] : (S, {\per_S}) \to (T, {\per_T})$ is mapped to the
  map $G[p] : \|S\|/{\per_S} \to \|T\|/{\per_T}$, as described above,
  $(G[p])([r]_S) = [p\,r]_T$. Obviously, $G[p]$ is tracked by~$p$.

  The functors $F$ and $G$ form an equivalence of categories. The
  composition $F \circ G$ is actually equal to identity, as is easily
  verified. A modest set~$(S, |S|, {\rz_S})$ is isomorphic to $T =
  G(F(S))$ by Lemma~\ref{lemma:iso-assembly} applied to the bijection
  which takes an $x \in S$ to $[r]_T$ where $r \in A_{|S|}$ is any
  realizer such that $r \rz_S x$. We leave the verification that the
  isomorphisms are natural as exercise.
\end{proof}


\subsection{Equivalence relations}
\label{sec:ers}

A per $(|S|, {\per_S})$ may be viewed as an equivalence relation on
$\|S\| = \set{r \in A_{|S|} \such r \per_S r}$. This gives us yet
another equivalent formulation of modest sets.

Let us state explicitly what the category $\Er{A, \comp{A}}$ of
equivalence relations is. The objects are triples $(S, |S|,
{\equiv_S})$ where $|S|$ is a type, $S \subseteq A_{|S|}$, and
$\equiv_S$ is an equivalence relation on~$S$. As in the case of pers,
a morphism $(S, |S|, {\equiv_S}) \to (T, |T|, {\equiv_T})$ is
represented by an extensional realizer $p \in \comp{A}_{|S| \to |T|}$.

The difference between pers and equivalence relations is mostly a
bureaucratic one. Nevertheless, it is useful to know about equivalence
relations because they sometimes have a useful alternative
description, see~\ref{sec:equilogical-spaces}.


\section{Schools of Computabile Mathematics}
\label{sec:schools}

Computable mathematics was developed by several ``schools'', mostly
independent of each other, and each coming from its own tradition. Our
approach covers most approaches to computable mathematics that have
been proposed. To get a particular variation we just choose an
appropriate TPCA with sub-TPCA:
%
\begin{enumerate}
\item When $A = \comp{A} = \NN$ is the first Kleene algebra we get the
  Russian school of \emph{recursive
    mathematics}~\cite{recursive-math}, also known as \emph{type I
    computability} because the underlying computational model is that
  of type~1 machines.
\item When $A = \Baire$ is the second Kleene algebra we get Kleene's
  \emph{function realizability}~\cite{KleeneSC:fouim}, also known by
  its newer name \emph{type two effectivity
    (TTE)}~\cite{Wei00}. This is currently the most
  influential school. There are actually three variants of TTE:
  %
  \begin{enumerate}
  \item $A = \comp{A} = \Baire$ is \emph{continuous} function
    realizability because maps are realized by arbitrary continuous
    realizers,
  \item $A = \Baire$ and $\comp{A} = \comp{\Baire}$, where
    $\comp{\Baire}$ is the set of computable sequences, is the
    \emph{relative} type 2 realizability,
  \item $A = \comp{A} = \comp{\Baire}$ is the \emph{computable}
    function realizability.
  \end{enumerate}
  %
  We will mostly study the continuous and the relative function
  realizaiblity.
\item When $A = \Scott$ is the graph model we get a version of
  realizability that is closely related to equilogical
  spaces~\cite{BauerA:equs}. Here too there are three variants:
  %
  \begin{enumerate}
  \item $A = \comp{A} = \Scott$ is the continuous model,
  \item $A = \Scott$ and $A = \comp{\Scott}$ is the family of
    c.e.~sets is the relative model,
  \item $A = \Scott = \comp{\Scott}$ is the computable model.
  \end{enumerate}
\item Closely related to the previous case is $A = U$ where~$U$ is a
  universal Scott domain~\cite{GunterScott}. This again gives as three
  variants of \emph{domain representations}~\cite{Bla97,Bla97a}.
\item The case $A = \PCFinf$ and $\comp{A} = \PCF$ was used by
  Mart{\'\i}n Escard\'o in his investigations of compact, exhausitble
  and searchable sets~\cite{Escardo}.
\end{enumerate}
%
We now look at some of these in greater detail.


\subsection{Recursive Mathematics}
\label{sec:recursive-math}

Recursive Mathematics is mathematics as developed in $\Rep{\NN}$, the
representations over the first Kleene algebra. It is usually phrased
in the language of representations, as follows.

A \emph{numbered set $(S, \delta_S)$} is a set $S$ with a partial
surjection $\delta_S : \NN \parto S$, called a \emph{numbering}
of~$S$. A function $f : S \to T$ is \emph{realized} by $n \in \NN$
when, for all $m \in \dom{\delta_S}$,
%
\begin{equation*}
  \text{$\defined{\pr{n}{m}}$ and $\delta_T(\pr{n}{m}) = f(\delta_S(m))$.}
\end{equation*}
%
A numbered set $(S, \delta_S)$ has countably many elements because it
is covered by a countable set $\dom{\delta_S}$.

% Reductions between numberings. This can be done more generally.

\subsection{Type Two Effectivity}
\label{sec:tte}

% Admissibility.

\subsection{Equilogical spaces}
\label{sec:equilogical-spaces}

\subsection{Domain representations}
\label{sec:domain-representations}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "notes"
%%% End: 
